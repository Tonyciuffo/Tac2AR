# HowTo Guide: Tac2AR Pipeline

# ===================================================================
# 1. PANORAMICA E WORKFLOW
# ===================================================================
panoramica:
  descrizione: "La pipeline Tac2AR automatizza la conversione di dati di imaging medico in asset 3D pronti per l'uso, ottimizzati per motori real-time come Unity. Il processo è diviso in due macro-fasi orchestrate da `main.py`."
  workflow:
    - fase: 1
      nome: "Segmentazione e Generazione Mesh"
      script_principale: "segmentator_pipeline.py"
      operazioni:
        - "Input: Scansione DICOM o file NIfTI."
        - "Tool: `TotalSegmentator` viene eseguito per creare un file NIfTI multi-etichetta."
        - "Logica: Le regole in `segmentMappings.yaml` vengono applicate per decidere quali segmenti esportare e come raggrupparli."
        - "Output: Mesh intermedie in formato `.stl` e un file `segments_data_manifest.json`."

    - fase: 2
      nome: "Processamento 3D e Texturing"
      script_principale: "blender_pipeline.py (eseguito all'interno di Blender)"
      operazioni:
        - "Input: Mesh `.stl` e `segments_data_manifest.json` dalla fase precedente."
        - "Logica: Il manifest viene arricchito con le informazioni sui materiali da `blender_shader_registry.yaml`."
        - "Tool: Blender viene usato per pulire, ottimizzare, creare UV, applicare materiali e fare il bake delle texture."
        - "Output: Modelli finali in formato `.glb` (PBR) e `.fbx` (Unity URP), completi di texture."

# ===================================================================
# 2. INSTALLAZIONE E SETUP
# ===================================================================
installazione:
  descrizione: "Seguire questi passaggi per configurare l'ambiente di sviluppo."
  prerequisiti:
    - "Python 3.10 o superiore."
    - "Git."
    - "Scheda grafica NVIDIA (consigliata per l'accelerazione GPU)."
  passaggi:
    - step: 1
      action: "Clonare il Repository"
      command: "git clone https://github.com/Tonyciuffo/Tac2AR.git"
    - step: 2
      action: "Creare e Attivare l'Ambiente Virtuale"
      details: "Sostituire i comandi a seconda del proprio OS."
      code: |
        # Windows
        python -m venv venv
        venv\Scripts\activate
        # Linux / macOS
        python3 -m venv venv
        source venv/bin/activate
    - step: 3
      action: "Installare le Dipendenze Python"
      command: "pip install -r requirements.txt"
    - step: 4
      action: "Installare PyTorch con Supporto GPU (Opzionale)"
      details: "Scegliere il comando in base alla propria scheda video."
      code: |
        # Per NVIDIA RTX serie 30/40 (CUDA 11.8)
        pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
        # Per NVIDIA RTX serie 50+ (CUDA 12.1)
        pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121
    - step: 5
      action: "Setup di Blender"
      details: "La pipeline richiede Blender 4.5 LTS. Se non è già presente nella root del progetto, scaricarlo, estrarlo e rinominare la cartella in 'Blender'."

# ===================================================================
# 3. STRUTTURA DIRECTORY E CONVENZIONI
# ===================================================================
struttura_e_convenzioni:
  struttura_directory:
    descrizione: "La pipeline si basa su una struttura di cartelle rigorosa, definita in `config.py`."
    albero: |
      Tac2Ar/
      ├── pipeline.log              # File di log principale con l'output di tutta la pipeline.
      ├── Blender/                  # Versione portable di Blender.
      ├── Input/
      │   └── {CLIENT_ID}/{PROJECT_SESSION_ID}/   # Dati grezzi (DICOM/NIfTI).
      ├── Output/
      │   └── {CLIENT_ID}/{PROJECT_SESSION_ID}/
      │       ├── segments_data_manifest.json
      │       ├── {PROJECT_SESSION_ID}_processed.glb
      │       └── Textures/
      ├── Shaders/                  # File .blend con i materiali.
      ├── Tmp/
      │   └── {CLIENT_ID}/{PROJECT_SESSION_ID}/
      │       └── mesh_intermediate/  # Contiene i file .stl grezzi.
      ├── main.py
      ├── config.py
      ├── segmentMappings.yaml
      └── blender_shader_registry.yaml

  convenzioni_di_denominazione:
    descrizione: "Seguire queste convenzioni è obbligatorio per il corretto funzionamento."
    regole:
      - categoria: "File di Output"
        items:
          - "Modelli 3D": "`{PROJECT_SESSION_ID}_processed.glb` / `.fbx`"
          - "Mesh Intermedie": "`{nome_segmento}.stl`"
          - "Texture": "`{nome_mesh}_{tipo_canale}.png`"
      - categoria: "Nuovo Materiale (Scalabilità)"
        items:
          - "Azione": "Creare un nuovo file `.blend` nella cartella `Shaders/`."
          - "Contenuto": "Il file deve contenere una scena con un oggetto a cui è applicato il nuovo materiale procedurale."
          - "Nome Materiale": "Il materiale in Blender DEVE essere nominato `{nome_file}_mat`. Esempio: per `skin.blend`, il materiale deve chiamarsi `skin_mat`."
          - "Registrazione": "Il nuovo materiale deve essere registrato in `blender_shader_registry.yaml`."

# ===================================================================
# 4. CONFIGURAZIONE
# ===================================================================
configurazione:
  - file: "config.py"
    descrizione: "File di configurazione principale per definire percorsi e parametri di alto livello."
    parametri_chiave:
      - "CLIENT_ID": "ID del cliente, corrisponde al nome della cartella in `Input/`."
      - "PROJECT_SESSION_ID": "ID della sessione, corrisponde alla sottocartella."
      - "TOTAL_SEGMENTATOR_TASKS": "Task per TotalSegmentator (es. `['total_mr']`)."
      - "MAX_FACES_PER_MESH": "Limite di poligoni per l'ottimizzazione."
      - "TEXTURE_SIZE": "Risoluzione delle texture (es. 512, 1024)."
      - "WORLD_SCALE_FACTOR": "Fattore di scala per convertire le unità del modello importato (tipicamente millimetri) nelle unità di Blender (metri). Il default è 0.001."

  - file: "segmentMappings.yaml"
    descrizione: "File di interfaccia utente per definire le regole di esportazione dei segmenti."
    struttura:
      - "individual_mesh_export": "Definisce il comportamento per ogni singolo segmento. Assegna la `biological_category`."
      - "combined_mesh_export": "Definisce gruppi di mesh basati sulla `biological_category`."

  - file: "blender_shader_registry.yaml"
    descrizione: "Catalogo dei materiali. Associa le categorie biologiche agli shader di Blender."
    struttura:
      - "shader_ref": "Elenco di tutti i materiali, con riferimento al file `.blend` e al nome del materiale interno."
      - "biological_categories": "Mappa una `biological_category` (da `segmentMappings.yaml`) a uno `shader_ref`."

# ===================================================================
# 5. WORKFLOW DETTAGLIATO: ASSOCIAZIONE SEGMENTO-MATERIALE
# ===================================================================
associazione_segmento_materiale:
  descrizione: "Questo è il flusso dati che collega un segmento anatomico al suo materiale finale. Il dizionario `all_segment_data` agisce da veicolo per queste informazioni."
  fasi:
    - fase: 1
      script: "segmentator_pipeline.py"
      obiettivo: "Costruire e arricchire il manifest dei segmenti."
      passaggi:
        - "1. Creazione": "Viene creato il dizionario `all_segment_data` con una voce per ogni segmento identificato da TotalSegmentator (es. 'spleen', 'vertebrae_L5')."
        - "2. Arricchimento SNOMED (Logica di Normalizzazione)": |
            Il nome del segmento grezzo (es. `vertebrae_L5`) spesso non corrisponde direttamente a una voce nel database SNOMED.
            Per risolvere questo, viene applicata una logica di ricerca intelligente:
            a. **Generazione Candidati:** La funzione `utils.generate_snomed_candidate_names` crea una lista di possibili nomi da cercare, applicando regole di normalizzazione (es. da `vertebrae_L5` a `vertebra_L5`, `vertebrae`, `vertebra`).
            b. **Lookup Iterativo:** Il sistema itera su questi candidati e cerca il primo che corrisponde a una voce nel database SNOMED.
            c. **Popolamento Dati:** Una volta trovato un match, i dettagli (categoria, tipo, regione) vengono usati per popolare la sezione `snomed_details` del manifest.
            Questo passaggio è cruciale per ottenere metadati medici accurati.
        - "3. Arricchimento Custom (Regole Utente)": |
            Il dizionario viene ulteriormente arricchito usando le regole di `segmentMappings.yaml`.
            Per ogni segmento, il codice cerca una regola corrispondente e popola il sotto-dizionario `custom_parameters`.
            L'informazione più importante aggiunta qui è la `biological_category` (es. "Organ", "Bone"), che funge da anello di congiunzione astratto con i materiali.
        - "4. Output": "Il dizionario `all_segment_data`, ora completo, viene salvato come `segments_data_manifest.json`."

    - fase: 2
      script: "blender_pipeline.py"
      obiettivo: "Usare il manifest per applicare i materiali."
      passaggi:
        - "1. Input": "Carica `segments_data_manifest.json` e `blender_shader_registry.yaml`."
        - "2. Logica di Fallback Materiale": "Per ogni segmento, determina lo `shader_ref` da usare con questa priorità: 1) Match diretto sul nome, 2) Match tramite `biological_category`, 3) Fallback allo shader di default."
        - "3. Assegnazione": "Applica fisicamente il materiale corretto all'oggetto corrispondente in Blender."

# ===================================================================
# 6. ESECUZIONE E LOGGING
# ===================================================================
esecuzione_e_logging:
  - titolo: "Esecuzione Standard"
    descrizione: "Per lanciare l'intera pipeline."
    passaggi:
      - "1. Configura `config.py` con `CLIENT_ID` e `PROJECT_SESSION_ID` corretti."
      - "2. Verifica le regole in `segmentMappings.yaml`."
      - "3. Esegui il comando `python main.py` dalla root del progetto (con l'ambiente virtuale attivo)."
      - "4. Monitoraggio e Risultati: L'avanzamento verrà stampato a console, ma l'output completo e dettagliato, inclusi tutti gli errori, verrà salvato nel file `pipeline.log` nella directory principale. Controlla questo file per il debug. I risultati finali saranno nella cartella `Output/`."

# ===================================================================
# 7. WORKFLOW ITERATIVO E RE-BAKING
# ===================================================================
workflow_iterativo:
  descrizione: "Questa sezione spiega come modificare materiali o texture e rigenerare gli output senza rieseguire l'intera pipeline da zero, sfruttando i file `.blend` intermedi."
  file_intermedi_blend:
    - file: "`{PROJECT_SESSION_ID}_01_procedural_materials.blend`"
      scopo: "È il file sorgente principale per i materiali. Contiene le mesh ottimizzate con i materiali procedurali (pre-bake) ancora intatti. **Questo è il file da modificare per cambiare l'aspetto di un materiale.**"
    - file: "`{PROJECT_SESSION_ID}_02_baked_materials.blend`"
      scopo: "È un'istantanea della scena dopo il bake, con le texture già collegate. Utile per debug e per verificare il risultato del bake, ma non per modifiche ai materiali sorgente."

  scenario_comune:
    domanda: "Posso modificare un materiale e rieseguire solo il bake?"
    risposta: "Sì, ma il processo è manuale. L'automazione è prevista ma non ancora implementata (`TODO -- rebake` in `main.py`)."
    procedura_manuale:
      - "1. Apri il file `{PROJECT_SESSION_ID}_01_procedural_materials.blend` in Blender."
      - "2. Modifica il materiale desiderato nello Shader Editor."
      - "3. Esegui il bake manuale tramite il pannello Render Properties di Blender."
      - "4. Esporta manualmente il modello nel formato desiderato."

# ===================================================================
# 8. RISOLUZIONE DEI PROBLEMI COMUNI
# ===================================================================
troubleshooting:
  - problema: "L'esecuzione fallisce immediatamente con `ModuleNotFoundError: No module named 'yaml'` (o `numpy`, etc.)"
    causa: "Le librerie Python necessarie non sono installate nell'ambiente Python *interno* di Blender, che è separato dal tuo ambiente virtuale."
    soluzione: "Devi installare le librerie usando l'eseguibile Python di Blender. Trova il percorso (es. `Blender/4.5/python/bin/python.exe`) e lancia: `percorso/a/python.exe -m pip install PyYAML numpy`."

  - problema: "Errore: `No module named 'bpy' durante la blender_pipeline`"
    causa: "Non è installato pyYaml nell'ambiente di Blender - bug noto"
    soluzione: "dalla root del progetto lanciare .\\Blender\\4.5\\python\\bin\\python.exe -m pip install pyYaml"

  - problema: "Errore: `Eseguibile di Blender non trovato...`"
    causa: "La variabile `BLENDER_EXECUTABLE` in `config.py` non punta al percorso corretto."
    soluzione: "Verifica che il percorso costruito in `config.py` a partire da `BLENDER_INSTALL_ROOT` sia corretto per la tua installazione."

  - problema: "Errore: `Nessun file NIfTI o cartella DICOM valida trovata...`"
    causa: "Le variabili `CLIENT_ID` e `PROJECT_SESSION_ID` in `config.py` non corrispondono alla struttura delle cartelle in `Input/`, oppure la cartella di input è vuota."
    soluzione: "Assicurati che `Input/{CLIENT_ID}/{PROJECT_SESSION_ID}/` esista e contenga i dati corretti."

  - problema: "La segmentazione fallisce o la GPU non viene usata."
    causa: "Problemi con l'installazione di PyTorch o con i driver CUDA."
    soluzione: "Assicurati di aver installato la versione corretta di PyTorch con supporto CUDA come specificato nella sezione di installazione. Verifica che i tuoi driver NVIDIA siano aggiornati."

  - problema: "Un materiale non viene applicato correttamente e l'oggetto risulta grigio."
    causa: "Errore nella catena di associazione: un errore di battitura in `segmentMappings.yaml` (nella `biological_category`) o in `blender_shader_registry.yaml` (nello `shader_ref` o nel nome del materiale)."
    soluzione: "Controlla attentamente i nomi in entrambi i file YAML. Verifica che la `biological_category` assegnata al segmento in `segmentMappings.yaml` esista in `blender_shader_registry.yaml` e che lo `shader_ref` a cui punta sia corretto."

  - problema: "I modelli 3D appaiono schiacciati o deformati su un asse (tipicamente quello verticale)."
    causa: "Il file NIfTI di input ha una spaziatura dei voxel 'anisotropica' (es. i voxel sono 0.7mm x 0.7mm sul piano XY, ma 5mm di spessore sull'asse Z). Se l'algoritmo di creazione della mesh non tiene conto di questa informazione, tratta ogni voxel come un cubo perfetto, causando la deformazione."
    soluzione: "La pipeline è stata corretta per leggere automaticamente i metadati di spaziatura dall'header del file NIfTI e applicarli durante la fase di generazione della mesh (marching cubes). Questo assicura che i modelli 3D finali rispettino le proporzioni anatomiche originali, indipendentemente dalla spaziatura dei voxel del file sorgente."

# ===================================================================
# 9. RIFERIMENTO OPERAZIONI (per Sviluppatori)
# ===================================================================
riferimento_operazioni:
  descrizione: "Mappatura tra le operazioni logiche e le funzioni nel codice."
  operazioni:
    - id: "OpsSeg01"
      nome: "Fetch Input Data"
      funzione: "segmentator_ops.fetch_input_files"
    - id: "OpsSeg02"
      nome: "Run Segmentation"
      funzione: "segmentator_ops.run_total_segmentator"
    - id: "OpsSeg03"
      nome: "Export STLs"
      funzione: "segmentator_ops.export_stl_from_multilabel_nii"
    - id: "OpsBld01"
      nome: "Import & Optimize Meshes"
      funzioni:
        - "blender_ops.import_meshes_into_blender_scene"
        - "blender_ops.decimate_mesh_objects"
    - id: "OpsBld02"
      nome: "Apply Materials"
      funzione: "blender_ops.apply_materials_from_manifest"
    - id: "OpsBld03"
      nome: "Bake Textures"
      funzione: "blender_ops.bake_textures"
    - id: "OpsBld04"
      nome: "Generate URP Map"
      funzione: "blender_ops.create_metallic_smoothness_map"
    - id: "OpsBld05"
      nome: "Export Models"
      funzioni:
        - "blender_ops.export_glb"
        - "blender_ops.export_fbx"